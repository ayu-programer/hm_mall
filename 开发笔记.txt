商品分类查询
	商品分类表设计注意点：商品分类是分层级的，如何区分儿子和爹的关系，就是在表中添加一个parentID字段

	通用mapper会把对象中的非空属性作为查询条件
	问题整体解决思路：
	    通过前端请求，分析请求方式（post，get..）,请求路径（http://api.leyou.com/api/item/category/list?pid=0）请求参数（pid），返回类型（是个json数组）
        进而来设计和构造controller和业务层

	利用cors解决跨域问题
	    具体使用：在网关中加入GlobalCorsConfig，添加跨域信息，定义请求方式，头信息等

商品的品牌管理和查询
    数据库设计的时候注意，tb_category_brand用于商品分类和品牌之间的关联，同时这表里没有外键，为什么不加外键呢？为了提高电商系统的性能，因为外键关联会影响到商品的删除
    也会影响数据库的读写性能
    根据返回数据的特点：有个用brand对象包装的list还有个总条数，所以选择用对象来包装返回结果
    具体逻辑处理时：包括1 分页，2.过滤  3.排序  4.查询   5.解析分页结果

商品新增功能

商品的文件上传
    注意一点：由于文件上传在经过zuul网关时，再高并发时可能会导致网络阻塞，zuul网关不可用，所以我们在做文件上传时最好绕过请求的缓存（也会经过zuul网关，只是不会在缓存请求）
    解决方法：通过nginx的指令对地址进行重写，修改到以/zuul为前缀

文件上传下载的升级
    通过fastDFS进行小文件的上传下载
    将代码中的字符串，及变量配置到配置文件中去
    具体操作步骤：
        1 在application.yml文件中配置 hm.upload.baseUrl 和 hm.upload.allowTypes属性
        2 定义 UploadProperties属性类
        3 在UploadService中注入 UploadProperties属性类 并使用属性替代字符串

spu与sku的关系
	spu：标准产品单位
	sku：库存量单位
	spu是一个抽象的商品集概念，作用：为了方便后台管理，
	sku因具体特征不同而区分出的商品，sku是具体要销售的商品，用户购买的是sku
	每一个分类都有统一的规格参数模板，但不同商品其参数值可能不同
		商品分类与规格模板是一对一关系
		商品分类与商品spu是一对多关系
		规模模板与商品spu是一对多关系
		商品spu保存有规格参数的具体值
		因为sku的特有属性是商品规格参数的一部分，
		所以可以将规格参数中的属性划分为 SKU 通用规格与SKU特有规格
		所以 spu与sku是一对多关系
		spu保存着所有sku共享的规格属性
		sku中保存每个sku特有的规格属性


将库存表和sku表分开处理的目的？
	因为库存字段写频率较高，而sku的其他字段以读为主，因此我们将两张表分离，读写不会干扰
	sku表中的indexes字段是一个特有规格属性字段，它表示spu属性模板中的对应下标组合字段
	因为在spu表中其实已经对特有规格参数及可选项作了保存，我们在sku表中将不同的角标串联起来作为spu下不同
	sku的标识，这就是index字段；；；、



当前规格参数的显示应该是以能够查询到的所有商品为准，而不是以数据库中的所有查询区间
解决思路是查询数据库中的商品尺寸规格，然后处理成段，再覆盖原来的值


进行搜索时，存的其实是spu，以spu为单位，主要包括，图片，价格，标题，副标题；暗藏的数据：spu的id，sku的id
首先要编写分类和品牌查询的相关服务
当实现将数据库中的数据同步到索引库时 需要用到Feign（使用feign之后，我们调用eureka 注册的其他服务，在代码中就像各个service之间相互调用那么简单。）
同时要想再serach-service中获取品牌信息和分类等信息，如果直接在serach-service中定义接口这种做法不好，因为调用方无法知道被调用方的接口信息和参数，
这样也将两者绑定死了
如何来操作？
在被调用方的item-interface中定义接口信息，在serach-service中引入hm-interface的包，然后继承interface中的接口
@FeignClient(value = "item-service")
public interface GoodsClient extends GoodsApi {
}


解决搜索服务与商品页面服务同步的问题
    两种传统路线，
         1 每一次对商品做增删改查时，同时修改索引库数据及页面数据
         2 搜索服务与商品页面服务对外提供接口，后台在商品增删改后调用接口
    但是这两种路线有缺陷，代码耦合度较高，违背了微服务的独立原则


    新的解决路线
         通过消息队列
         消息队列的优势：消息队列分为生产者和消费者，生产者负责消息的发送，消费者负责消息的接收，两者是异步的，而且也只关注消息的接收与发送，
         没有业务逻辑的侵入，对代码的耦合度较低
         消息队列中的问题：
            1 消息丢失如何处理？(如果消费者领取消息后，还没执行操作就挂掉了呢？或者抛出了异常？消息消费失败，这时消息就丢失了)
             采用rabbitmq的ack确认机制
             而ack机制分为两种。自动ack与手动ack，
             两者区别：自动ack是消息一旦被接收，那么消费者就会自动发送ack； 而手动ack是消息接收后不会自动发送ack，需要手动来调用
             而如何来去选择 就要看消息的重要性
             - 如果消息不太重要，丢失也没有影响，那么自动ACK会比较方便
             - 如果消息非常重要，不容丢失。那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除。
                如果此时消费者宕机，那么消息就丢失了。
               如何实现    channel.basicConsume(QUEUE_NAME, false, consumer);  当boolean类型值为true为自动ack，
                          反之为false同时当为手动ack时要注意如果设置为手动ack，一定要有手动ack代码   channel.basicAck(envelope.getDeliveryTag(), false);
              引申：如果消息在消费者还未来得及消费时就丢失了？该如何处理？
                通过将消息持久化，但是消息持久化的前提是：队列、Exchange都持久化，消息的持久化是在发送消息时设置devilerMode为2

                对于生产者方出现消息丢失时可以采用生产者确认机制来保证，就是MQ向生产方发送消息
                而对于除MQ以外的其他消息工具不带生产者确认时，应该怎么做？先将消息持久化到数据库，并记录消息状态（可靠消息服务）

            2 如何避免消息堆积？
                什么情况会消息堆积？比如第三方的发短信，转账业务，或者大量订单
                1）采用workqueue，多个消费者监听同一队列
                2）接收到消息后，通过线程池，异步消费

            3 如何避免消息的重复执行？
            要保证消息的幂等性（同一接口被重复执行，其结果一致）
           3 消息队列的几种类型？
                simple（基本消息模型），--------》一个生产者，一个消费者，一个队列
                worker（work消息模型），----》一个生产者，多个消费者，一个队列
                    工作队列模型 默认是队列把消息每一轮平均分给多个消费者，这样就有个缺点，无法根据消费者的自身能力来去消费；
                     解决办法就是配置   channel.basicQos(1); （设置每个消费者同时只能处理一条消息）---》能者多劳
                订阅模型
                fanout（发布订阅模式--fanout）----------》一个生产者，可以有多个消费者，每个消费者绑定自己的队列，每个队列都要绑定到交换机，
                                                          生产者发送的消息只能发送到交换机，
                    注意 只有队列可以存消息，而消费者是将消息发送到交换机的，但是交换机是不存储消息的，所以如果没有队列绑定
                    该交换机，那么消息就会丢失
                direct（订阅模型--direct） ------》队列与交换机的绑定不能是任意绑定，必须要指定至少一个routingkey（路由key）、

                Topic（订阅模型--Topic）--------》与direct模式类似，但是通过通配符的方式进行配置，所以更加灵活

         具体的业务思路：
            1 当对商品数据做增删改查后会调用消息队列，发送消息，也不关心消息被谁接收
            2 搜索服务和静态页面服务接收到消息后，分别去处理索引库和静态页面

         如何实现？
           在hm-item服务中当对商品做增删改查时执行mq操作；
           同时在hm-search服务中监听商品操作，


实现用户中心服务
    具体包括：用户的注册，登录，个人信息管理，用户地址管理，用户收藏管理，订单管理，优惠券
    具体操作：新建hm-user

 实现发送短信服务
 *因为短信发送API调用时长的不确定性，为了提高程序的响应速度
 短信发送我们都将采用异步发送方式，即：
     - **短信服务监听MQ消息，收到消息后发送短信**。
     - **其它服务要发送短信时，通过MQ通知短信微服务。**
 短信服务心得总结：
    1 短信服务因为不止在一个服务模块用到，所以独立出来作为一个模块
    2 而具体的发送短信请求通过mq消息通知，
        即其他服务（如用户服务）：    需要发送短信时--》（1 生成6位数字验证码，2 将验证码存到redis中，并设置有效期，3调用mq消息 通知短信服务）
                        短信服务：短信服务处理短信时-->（1 短信服务的listener负责监听mq传递的消息；  2 调用发短信接口，3 短信服务发送短信返回响应（验证码））

    3 短信服务中用到了一些参数，这些参数可以独立出来放到配置文件中去，
      然后定义一个bean类（包含这些属性）且加上@ConfigurationProperties(prefix = "ly.sms")注解，
      进而在其他类中 加上@EnableConfigurationProperties(SmsProperties.class)就可以读取这些参数

    4 针对手机号码进行限流
        1)在短信工具类，发送短信成功后，将手机号作为key，时间戳作为value存到redis中
        2)然后在每次方法调用前，从redis中取出当前手机号的key对应的value值
        3)判断当前时间与value值的差值是否大于1，如果大于1 调用发送短信，否则直接返回 null


授权中心
    1 有状态与无状态区分
        有状态服务：即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理
        缺点：1）服务端保存了大量的数据，增加了服务端的压力
              2）服务端保存了用户的状态，无法进行水平扩展
              3）客户端的请求依赖与服务端
        无状态服务：服务端不保存任何客户端请求者信息，客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份
        优点：1）减轻了服务端的压力
              2）服务端可以进行任意的迁移和伸缩
              3）客户端的请求信息 不依赖与服务端的信息 任何多次请求不需要必须访问到同一台服务
        典型代表：rest服务

    2 如何实现无状态服务？
       无状态登录的流程：
       1）客户端第一次请求访问服务端，服务端会对用户进行信息认证
       2）认证通过后，会将用户信息加密形成token，返回给客户端，作为登录凭证
       3）以后每次请求，客户端都会携带认证的token
       4）客户端会对token进行解密，判断是否有效
       登录过程中的关键点：token的安全性
       具体实现：我们将采用`JWT + RSA非对称加密`

   3 结合RSA的鉴权
       1）用户在客户端请求 发起认证
       2）授权中心会对用户信息进行校验，然后通过私钥生成jwt凭证
       3）返回jwt给用户
       4）用户会携带jwt进行访问
       5）zuul网关会直接通过公钥解析jwt，进行验证，验证通过之后则放行
       6）请求到达微服务，微服务直接用公钥解析jwt，获取用户信息，无需访问授权中心

   4 授权中心的职责：
        1）用户鉴权
            接收用户的请求，通过用户中心的接口进行校验，通过后，使用私钥生成jwt并返回

        2）服务鉴权
            微服务之间通过鉴权中心进行认证




